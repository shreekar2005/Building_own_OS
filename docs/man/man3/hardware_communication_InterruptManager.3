.TH "hardware_communication::InterruptManager" 3 "Fri Oct 24 2025 10:32:01" "OSOS - Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
hardware_communication::InterruptManager \- Manages the Interrupt Descriptor Table (IDT) and Programmable Interrupt Controllers (PICs), dispatching interrupts to registered handlers\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include 'kinterrupt\&.hpp'\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBInterruptManager\fP (\fBessential::GDT\fP *gdt)"
.br
.RI "Constructs an \fBInterruptManager\fP, initializes the PICs, and populates the IDT\&. "
.ti -1c
.RI "\fB~InterruptManager\fP ()"
.br
.RI "Destroys the \fBInterruptManager\fP object\&. "
.ti -1c
.RI "void \fBinstallTable\fP ()"
.br
.RI "Loads the Interrupt Descriptor Table (IDT) into the CPU's IDTR register\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBactivate\fP ()"
.br
.RI "Enables interrupts globally by executing the 'sti' instruction\&. "
.ti -1c
.RI "static void \fBdeactivate\fP ()"
.br
.RI "Disables interrupts globally by executing the 'cli' instruction\&. "
.ti -1c
.RI "static uintptr_t \fBhandleInterrupt\fP (uint8_t interruptNumber, uintptr_t esp)"
.br
.RI "The central interrupt dispatching function called by assembly stubs\&. "
.ti -1c
.RI "static void \fBprintLoadedTable\fP ()"
.br
.RI "Prints the details of all entries in the currently loaded IDT\&. "
.ti -1c
.RI "static void \fBprintLoadedTableHeader\fP ()"
.br
.RI "Prints the header information (base, limit, count) of the currently loaded IDT\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "uint32_t \fBbase\fP"
.br
.ti -1c
.RI "uint16_t \fBlimit\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBsetIDTEntry\fP (uint8_t interruptNumber, uint16_t codeSegmentSelectorOffset, void(*handler)(), uint8_t DescriptorPrivilegeLever, uint8_t DescriptorType)"
.br
.RI "Populates a specific entry in the Interrupt Descriptor Table (IDT)\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBInterruptHandler\fP * \fBhandlers\fP [256]"
.br
.ti -1c
.RI "\fBIDT_row\fP \fBinterruptDescriptorTable\fP [256]"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBhardware_communication::Port8BitSlow\fP \fBpicMasterCommand\fP"
.br
.RI "Command port for the Master PIC (8259A)\&. "
.ti -1c
.RI "static \fBhardware_communication::Port8BitSlow\fP \fBpicMasterData\fP"
.br
.RI "Data port for the Master PIC (8259A)\&. "
.ti -1c
.RI "static \fBhardware_communication::Port8BitSlow\fP \fBpicSlaveCommand\fP"
.br
.RI "Command port for the Slave PIC (8259A)\&. "
.ti -1c
.RI "static \fBhardware_communication::Port8BitSlow\fP \fBpicSlaveData\fP"
.br
.RI "Data port for the Slave PIC (8259A)\&. "
.in -1c
.SH "Detailed Description"
.PP 
Manages the Interrupt Descriptor Table (IDT) and Programmable Interrupt Controllers (PICs), dispatching interrupts to registered handlers\&. 
.PP
Definition at line \fB47\fP of file \fBkinterrupt\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "hardware_communication::InterruptManager::InterruptManager (\fBessential::GDT\fP * gdt)"

.PP
Constructs an \fBInterruptManager\fP, initializes the PICs, and populates the IDT\&. 
.PP
\fBParameters\fP
.RS 4
\fIgdt\fP A pointer to the Global Descriptor Table instance, needed to get the kernel code segment selector\&. 
.RE
.PP

.PP
Definition at line \fB33\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
33                                                                          {
34     // ICW1: Start Initialization Sequence\&. Both PICs are told to listen for 3 more bytes of config data\&.
35     picMasterCommand\&.write(0x11);
36     picSlaveCommand\&.write(0x11);
37 
38     // ICW2: Vector Remapping\&.
39     // Master is told to remap its IRQs (0\-7) to CPU vectors 0x20\-0x27\&.
40     picMasterData\&.write(0x20);
41     // Slave is told to remap its IRQs (8\-15) to CPU vectors 0x28\-0x2F\&.
42     picSlaveData\&.write(0x28);
43 
44     // ICW3: Chaining Configuration\&.
45     // Master is told a slave is connected on its IRQ 2 line (0x04 = bit 2 set)\&.
46     picMasterData\&.write(0x04);
47     // Slave is told its identity is 2\&.
48     picSlaveData\&.write(0x02);
49 
50     // ICW4: Environment Information\&.
51     // Both are told to operate in standard "8086/88" mode\&.
52     picMasterData\&.write(0x01);
53     picSlaveData\&.write(0x01);
54 
55     // OCW1: Interrupt Masking\&.
56     // This is the final step, enabling all interrupts by writing a mask of all zeros\&.
57     picMasterData\&.write(0x00);
58     picSlaveData\&.write(0x00);
59 
60     base=(uintptr_t)&interruptDescriptorTable;
61     limit = sizeof(interruptDescriptorTable) \- 1;
62 
63     uint16_t kernelCSselectorOffset = gdt\->kernel_CS_selector();
64     uint8_t IDT_INTERRUPT_GATE=0xE;
65     for(int i=0; i<256; i++){
66         setIDTEntry(i, kernelCSselectorOffset, &ignoreInterrupt, 0, IDT_INTERRUPT_GATE);
67     }
68 
69     // Set handlers for hardware interrupts
70     setIDTEntry(0x20, kernelCSselectorOffset, &handleIRQ0x00, 0, IDT_INTERRUPT_GATE); // Timer
71     setIDTEntry(0x21, kernelCSselectorOffset, &handleIRQ0x01, 0, IDT_INTERRUPT_GATE); // Keyboard
72     setIDTEntry(0x2C, kernelCSselectorOffset, &handleIRQ0x0C, 0, IDT_INTERRUPT_GATE); // PS/2 Mouse
73 }
.fi

.PP
References \fBbase\fP, \fBhandleIRQ0x00()\fP, \fBhandleIRQ0x01()\fP, \fBhandleIRQ0x0C()\fP, \fBignoreInterrupt()\fP, \fBessential::GDT::kernel_CS_selector()\fP, and \fBlimit\fP\&.
.SS "hardware_communication::InterruptManager::~InterruptManager ()"

.PP
Destroys the \fBInterruptManager\fP object\&. 
.PP
Definition at line \fB76\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
76 {}
.fi

.SH "Member Function Documentation"
.PP 
.SS "void hardware_communication::InterruptManager::activate ()\fC [static]\fP"

.PP
Enables interrupts globally by executing the 'sti' instruction\&. 
.PP
Definition at line \fB117\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
117                                                      {
118     __asm__ volatile ("sti");
119     basic::printf("Interrupts Activated\\n");
120 }
.fi

.PP
References \fBbasic::printf()\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void hardware_communication::InterruptManager::deactivate ()\fC [static]\fP"

.PP
Disables interrupts globally by executing the 'cli' instruction\&. 
.PP
Definition at line \fB122\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
122                                                        {
123     __asm__ volatile ("cli");
124     basic::printf("Interrupts Deactivated\\n");
125 }
.fi

.PP
References \fBbasic::printf()\fP\&.
.SS "uintptr_t hardware_communication::InterruptManager::handleInterrupt (uint8_t interruptNumber, uintptr_t esp)\fC [static]\fP"

.PP
The central interrupt dispatching function called by assembly stubs\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterruptNumber\fP The number of the interrupt that occurred\&. 
.br
\fIesp\fP The stack pointer (Extended Stack Pointer) from the context of the interrupted process\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The updated stack pointer, typically the same as the input unless the handler modified the stack frame\&. 
.RE
.PP

.PP
Definition at line \fB185\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
185                                                                                                        {
186     // Use the global pointer "installed_interrupt_manager" to access the current interrupt manager
187     if(installed_interrupt_manager\->handlers[interruptNumber]!=nullptr){
188         esp = installed_interrupt_manager\->handlers[interruptNumber]\->handleInterrupt(esp);
189     }
190 
191     else if(interruptNumber!=0x20){ //0x20 is Hardware Timer Interrupt
192         basic::printf("UNHANDLED INTERRUPT %#hx\\n",interruptNumber);
193     }
194 
195     // Hardware interrupts must still be acknowledged to the PIC
196     if (0x20 <=interruptNumber && interruptNumber <= 0x2F) {
197         picMasterCommand\&.write(0x20);
198         if (0x28 <= interruptNumber) picSlaveCommand\&.write(0x20);
199     }
200     
201     return esp;
202 }
.fi

.PP
References \fBhardware_communication::InterruptHandler::handleInterrupt()\fP, \fBhandlers\fP, \fBinstalled_interrupt_manager\fP, and \fBbasic::printf()\fP\&.
.SS "void hardware_communication::InterruptManager::installTable ()"

.PP
Loads the Interrupt Descriptor Table (IDT) into the CPU's IDTR register\&. 
.PP
Definition at line \fB100\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
100                                                          {
101     installed_interrupt_manager=this;
102     struct IDT_Pointer {
103         uint16_t limit;
104         uint32_t base;
105     } __attribute__((packed));
106 
107     IDT_Pointer idt_ptr;
108     idt_ptr\&.limit = this\->limit;
109     idt_ptr\&.base = this\->base;
110 
111     __asm__ volatile ("lidt %0" : : "m"(idt_ptr));
112     basic::printf("IDT Installed\\n");
113 }
.fi

.PP
References \fBhardware_communication::__attribute__\fP, \fBbase\fP, \fBinstalled_interrupt_manager\fP, \fBlimit\fP, and \fBbasic::printf()\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void hardware_communication::InterruptManager::printLoadedTable ()\fC [static]\fP"

.PP
Prints the details of all entries in the currently loaded IDT\&. 
.PP
Definition at line \fB128\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
128                                                               {
129     struct IDT_Pointer {
130         uint16_t limit;
131         uint32_t base;
132     } __attribute__((packed));
133 
134     IDT_Pointer idt_ptr;
135     __asm__ volatile ("sidt %0" : "=m"(idt_ptr));
136 
137     basic::printf("\-\-\-\\n");
138     basic::printf("INFO about : Currently Loaded IDT\\n");
139     basic::printf("Base Address: %#x\\n", idt_ptr\&.base);
140     basic::printf("Limit: %#x (%d bytes)\\n", idt_ptr\&.limit, idt_ptr\&.limit);
141     basic::printf("Entries: %d\\n", (idt_ptr\&.limit + 1) / sizeof(hardware_communication::IDT_row));
142     basic::printf("\-\-\-\\n");
143 
144     basic::printf(" Idx | Handler Address | Selector | Access Flags\\n");
145     hardware_communication::IDT_row* current_idt = (hardware_communication::IDT_row*)idt_ptr\&.base;
146     uint32_t num_entries = (idt_ptr\&.limit + 1) / sizeof(hardware_communication::IDT_row);
147     for (uint32_t i = 0; i < num_entries; i++) {
148         uint32_t handler_address = (current_idt[i]\&.handlerAddressHighbits << 16) | current_idt[i]\&.handlerAddressLowbits;
149 
150         if (handler_address != 0) {
151             basic::printf(" %3d | %#015x | %#08x | %#012x\\n", 
152                    i, 
153                    handler_address, 
154                    current_idt[i]\&.kernelCodeSegmentSelector,
155                    current_idt[i]\&.access
156             );
157         }
158     }
159     basic::printf("\-\-\-\\n");
160 }
.fi

.PP
References \fBhardware_communication::__attribute__\fP, \fBaccess\fP, \fBbase\fP, \fBhardware_communication::IDT_row::handlerAddressHighbits\fP, \fBhandlerAddressLowbits\fP, \fBkernelCodeSegmentSelector\fP, \fBlimit\fP, and \fBbasic::printf()\fP\&.
.SS "void hardware_communication::InterruptManager::printLoadedTableHeader ()\fC [static]\fP"

.PP
Prints the header information (base, limit, count) of the currently loaded IDT\&. 
.PP
Definition at line \fB163\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
163                                                                    {
164 
165     struct IDT_Pointer {
166         uint16_t limit;
167         uint32_t base;
168     } __attribute__((packed));
169 
170     IDT_Pointer idt_ptr;
171     __asm__ volatile ("sidt %0" : "=m"(idt_ptr));
172     basic::printf("\-\-\-\\n");
173     basic::printf("INFO about : Currently Loaded IDT\\n");
174     basic::printf("Base Address: %#x\\n", idt_ptr\&.base);
175     basic::printf("Limit: %#x (%d bytes)\\n", idt_ptr\&.limit, idt_ptr\&.limit);
176     basic::printf("Entries: %d\\n", (idt_ptr\&.limit + 1) / sizeof(hardware_communication::IDT_row));
177     basic::printf("\-\-\-\\n");
178 }
.fi

.PP
References \fBhardware_communication::__attribute__\fP, \fBbase\fP, \fBlimit\fP, and \fBbasic::printf()\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void hardware_communication::InterruptManager::setIDTEntry (uint8_t interruptNumber, uint16_t codeSegmentSelectorOffset, void(*)() handler, uint8_t DescriptorPrivilegeLever, uint8_t DescriptorType)\fC [protected]\fP"

.PP
Populates a specific entry in the Interrupt Descriptor Table (IDT)\&. 
.PP
\fBParameters\fP
.RS 4
\fIinterruptNumber\fP The index of the IDT entry to set (0-255)\&. 
.br
\fIcodeSegmentSelectorOffset\fP The segment selector for the interrupt handler code\&. 
.br
\fIhandler\fP A function pointer to the assembly stub that handles the interrupt\&. 
.br
\fIDescriptorPrivilegeLever\fP The DPL (Descriptor Privilege Level) for the interrupt gate\&. 
.br
\fIDescriptorType\fP The type of the descriptor (e\&.g\&., 0xE for 32-bit Interrupt Gate)\&. 
.RE
.PP

.PP
Definition at line \fB84\fP of file \fBkinterrupt\&.cpp\fP\&..PP
.nf
89                            {
90         const uint8_t IDT_DESC_PRESET= 0x80;
91         interruptDescriptorTable[interruptNumber]\&.handlerAddressLowbits=(uint32_t)handler & 0xFFFF;
92         interruptDescriptorTable[interruptNumber]\&.handlerAddressHighbits=((uint32_t)handler >> 16) & 0xFFFF;
93         interruptDescriptorTable[interruptNumber]\&.reserved=0;
94         interruptDescriptorTable[interruptNumber]\&.access=IDT_DESC_PRESET | DescriptorType | ((DescriptorPrivilegeLever & 3) << 5);
95         interruptDescriptorTable[interruptNumber]\&.kernelCodeSegmentSelector=codeSegmentSelectorOffset;
96 }
.fi

.SH "Member Data Documentation"
.PP 
.SS "uint32_t hardware_communication::InterruptManager::base"

.PP
Definition at line \fB53\fP of file \fBkinterrupt\&.hpp\fP\&.
.SS "\fBInterruptHandler\fP* hardware_communication::InterruptManager::handlers[256]\fC [protected]\fP"

.PP
Definition at line \fB58\fP of file \fBkinterrupt\&.hpp\fP\&.
.PP
Referenced by \fBhardware_communication::InterruptHandler::InterruptHandler()\fP, and \fBhandleInterrupt()\fP\&.
.SS "\fBIDT_row\fP hardware_communication::InterruptManager::interruptDescriptorTable[256]\fC [protected]\fP"

.PP
Definition at line \fB55\fP of file \fBkinterrupt\&.hpp\fP\&.
.SS "uint16_t hardware_communication::InterruptManager::limit"

.PP
Definition at line \fB52\fP of file \fBkinterrupt\&.hpp\fP\&.
.SS "\fBhardware_communication::Port8BitSlow\fP hardware_communication::InterruptManager::picMasterCommand\fC [static]\fP, \fC [protected]\fP"

.PP
Command port for the Master PIC (8259A)\&. 
.PP
Definition at line \fB66\fP of file \fBkinterrupt\&.hpp\fP\&.
.SS "\fBhardware_communication::Port8BitSlow\fP hardware_communication::InterruptManager::picMasterData\fC [static]\fP, \fC [protected]\fP"

.PP
Data port for the Master PIC (8259A)\&. 
.PP
Definition at line \fB67\fP of file \fBkinterrupt\&.hpp\fP\&.
.SS "\fBhardware_communication::Port8BitSlow\fP hardware_communication::InterruptManager::picSlaveCommand\fC [static]\fP, \fC [protected]\fP"

.PP
Command port for the Slave PIC (8259A)\&. 
.PP
Definition at line \fB68\fP of file \fBkinterrupt\&.hpp\fP\&.
.SS "\fBhardware_communication::Port8BitSlow\fP hardware_communication::InterruptManager::picSlaveData\fC [static]\fP, \fC [protected]\fP"

.PP
Data port for the Slave PIC (8259A)\&. 
.PP
Definition at line \fB69\fP of file \fBkinterrupt\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OSOS - Documentation from the source code\&.
