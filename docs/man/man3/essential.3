.TH "essential" 3 "Fri Oct 24 2025 00:40:52" "OSOS - Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
essential
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBatexit_func_entry_t\fP"
.br
.ti -1c
.RI "class \fBGDT\fP"
.br
.ti -1c
.RI "class \fBGDT_row\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "class \fBessential::GDT_row\fP \fB__attribute__\fP ((packed))"
.br
.ti -1c
.RI "void \fB__callConstructors\fP ()"
.br
.ti -1c
.RI "void \fB__cxa_finalize\fP (void *f)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "class \fBessential::GDT\fP essential::__attribute__ ((packed))"

.SS "void essential::__callConstructors ()"

.PP
Definition at line \fB6\fP of file \fBkicxxabi\&.cpp\fP\&..PP
.nf
6                                   {
7     for (void (**p)() = &ctors_start; p < &ctors_end; ++p)
8     {
9         (*p)(); // Call the constructor
10     }
11 }
.fi

.PP
References \fBctors_end\fP, and \fBctors_start\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void essential::__cxa_finalize (void * f)"

.PP
Definition at line \fB40\fP of file \fBkicxxabi\&.cpp\fP\&..PP
.nf
41 {
42     uarch_t i = __atexit_func_count;
43     if (!f)
44     {
45         /*
46         * According to the Itanium C++ ABI, if essential::__cxa_finalize is called without a
47         * function ptr, then it means that we should destroy EVERYTHING MUAHAHAHA!!
48         *
49         * TODO:
50         * Note well, however, that deleting a function from here that contains a __dso_handle
51         * means that one link to a shared object file has been terminated\&. In other words,
52         * We should monitor this list (optional, of course), since it tells us how many links to 
53         * an object file exist at runtime in a particular application\&. This can be used to tell 
54         * when a shared object is no longer in use\&. It is one of many methods, however\&.
55         **/
56         //You may insert a prinf() here to tell you whether or not the function gets called\&. Testing
57         //is CRITICAL!
58         while (i\-\-)
59         {
60             if (__atexit_funcs[i]\&.destructor_func)
61             {
62                 /* ^^^ That if statement is a safeguard\&.\&.\&.
63                 * To make sure we don't call any entries that have already been called and unset at runtime\&.
64                 * Those will contain a value of 0, and calling a function with value 0
65                 * will cause undefined behaviour\&. Remember that linear address 0, 
66                 * in a non\-virtual address space (physical) contains the IVT and BDA\&.
67                 *
68                 * In a virtual environment, the kernel will receive a page fault, and then probably
69                 * map in some trash, or a blank page, or something stupid like that\&.
70                 * This will result in the processor executing trash, and\&.\&.\&.we don't want that\&.
71                 **/
72                 (*__atexit_funcs[i]\&.destructor_func)(__atexit_funcs[i]\&.obj_ptr);
73             };
74         };
75         return;
76     };
77 
78     while (i\-\-)
79     {
80         /*
81         * The ABI states that multiple calls to the __cxa_finalize(destructor_func_ptr) function
82         * should not destroy objects multiple times\&. Only one call is needed to eliminate multiple
83         * entries with the same address\&.
84         *
85         * FIXME:
86         * This presents the obvious problem: all destructors must be stored in the order they
87         * were placed in the list\&. I\&.e: the last initialized object's destructor must be first
88         * in the list of destructors to be called\&. But removing a destructor from the list at runtime
89         * creates holes in the table with unfilled entries\&.
90         * Remember that the insertion algorithm in __cxa_atexit simply inserts the next destructor
91         * at the end of the table\&. So, we have holes with our current algorithm
92         * This function should be modified to move all the destructors above the one currently
93         * being called and removed one place down in the list, so as to cover up the hole\&.
94         * Otherwise, whenever a destructor is called and removed, an entire space in the table is wasted\&.
95         **/
96         if (__atexit_funcs[i]\&.destructor_func == f)
97         {
98             /* 
99             * Note that in the next line, not every destructor function is a class destructor\&.
100             * It is perfectly legal to register a non class destructor function as a simple cleanup
101             * function to be called on program termination, in which case, it would not NEED an
102             * object This pointer\&. A smart programmer may even take advantage of this and register
103             * a C function in the table with the address of some structure containing data about
104             * what to clean up on exit\&.
105             * In the case of a function that takes no arguments, it will simply be ignore within the
106             * function itself\&. No worries\&.
107             **/
108             (*__atexit_funcs[i]\&.destructor_func)(__atexit_funcs[i]\&.obj_ptr);
109             __atexit_funcs[i]\&.destructor_func = 0;
110             
111             /*
112             * Notice that we didn't decrement __atexit_func_count: this is because this algorithm
113             * requires patching to deal with the FIXME outlined above\&.
114             **/
115         };
116     };
117 };
.fi

.PP
References \fB__atexit_func_count\fP, \fB__atexit_funcs\fP, and \fBessential::atexit_func_entry_t::destructor_func\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for OSOS - Documentation from the source code\&.
