.TH "essential" 3 "Fri Oct 24 2025 10:32:01" "OSOS - Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
essential
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBatexit_func_entry_t\fP"
.br
.RI "Structure to hold a registered C++ ABI exit function (destructor)\&. "
.ti -1c
.RI "class \fBGDT\fP"
.br
.RI "Manages the Global Descriptor Table (\fBGDT\fP), holding segment descriptors for the CPU\&. "
.ti -1c
.RI "class \fBGDT_row\fP"
.br
.RI "Represents a single 8-byte segment descriptor entry in the Global Descriptor Table (\fBGDT\fP)\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "class \fBessential::GDT_row\fP \fB__attribute__\fP ((packed))"
.br
.ti -1c
.RI "void \fB__callConstructors\fP ()"
.br
.RI "Iterates over the list of global constructors and calls them to initialize global C++ objects\&. "
.ti -1c
.RI "void \fB__cxa_finalize\fP (void *f)"
.br
.RI "Executes registered destructors/cleanup functions\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "class \fBessential::GDT\fP essential::__attribute__ ((packed))"

.SS "void essential::__callConstructors ()"

.PP
Iterates over the list of global constructors and calls them to initialize global C++ objects\&. 
.PP
Definition at line \fB7\fP of file \fBkicxxabi\&.cpp\fP\&..PP
.nf
7                                   {
8     for (void (**p)() = &ctors_start; p < &ctors_end; ++p)
9     {
10         (*p)(); // Call the constructor
11     }
12 }
.fi

.PP
References \fBctors_end\fP, and \fBctors_start\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void essential::__cxa_finalize (void * f)"

.PP
Executes registered destructors/cleanup functions\&. 
.PP
\fBParameters\fP
.RS 4
\fIf\fP If non-null, only destructors associated with this function pointer are called\&. If null, all registered destructors are called in reverse order of registration\&. 
.RE
.PP

.PP
Definition at line \fB49\fP of file \fBkicxxabi\&.cpp\fP\&..PP
.nf
50 {
51     uarch_t i = __atexit_func_count;
52     if (!f)
53     {
54         /*
55         * According to the Itanium C++ ABI, if essential::__cxa_finalize is called without a
56         * function ptr, then it means that we should destroy EVERYTHING MUAHAHAHA!!
57         *
58         * TODO:
59         * Note well, however, that deleting a function from here that contains a __dso_handle
60         * means that one link to a shared object file has been terminated\&. In other words,
61         * We should monitor this list (optional, of course), since it tells us how many links to 
62         * an object file exist at runtime in a particular application\&. This can be used to tell 
63         * when a shared object is no longer in use\&. It is one of many methods, however\&.
64         **/
65         //You may insert a prinf() here to tell you whether or not the function gets called\&. Testing
66         //is CRITICAL!
67         while (i\-\-)
68         {
69             if (__atexit_funcs[i]\&.destructor_func)
70             {
71                 /* ^^^ That if statement is a safeguard\&.\&.\&.
72                 * To make sure we don't call any entries that have already been called and unset at runtime\&.
73                 * Those will contain a value of 0, and calling a function with value 0
74                 * will cause undefined behaviour\&. Remember that linear address 0, 
75                 * in a non\-virtual address space (physical) contains the IVT and BDA\&.
76                 *
77                 * In a virtual environment, the kernel will receive a page fault, and then probably
78                 * map in some trash, or a blank page, or something stupid like that\&.
79                 * This will result in the processor executing trash, and\&.\&.\&.we don't want that\&.
80                 **/
81                 (*__atexit_funcs[i]\&.destructor_func)(__atexit_funcs[i]\&.obj_ptr);
82             };
83         };
84         return;
85     };
86 
87     while (i\-\-)
88     {
89         /*
90         * The ABI states that multiple calls to the __cxa_finalize(destructor_func_ptr) function
91         * should not destroy objects multiple times\&. Only one call is needed to eliminate multiple
92         * entries with the same address\&.
93         *
94         * FIXME:
95         * This presents the obvious problem: all destructors must be stored in the order they
96         * were placed in the list\&. I\&.e: the last initialized object's destructor must be first
97         * in the list of destructors to be called\&. But removing a destructor from the list at runtime
98         * creates holes in the table with unfilled entries\&.
99         * Remember that the insertion algorithm in __cxa_atexit simply inserts the next destructor
100         * at the end of the table\&. So, we have holes with our current algorithm
101         * This function should be modified to move all the destructors above the one currently
102         * being called and removed one place down in the list, so as to cover up the hole\&.
103         * Otherwise, whenever a destructor is called and removed, an entire space in the table is wasted\&.
104         **/
105         if (__atexit_funcs[i]\&.destructor_func == f)
106         {
107             /* * Note that in the next line, not every destructor function is a class destructor\&.
108             * It is perfectly legal to register a non class destructor function as a simple cleanup
109             * function to be called on program termination, in which case, it would not NEED an
110             * object This pointer\&. A smart programmer may even take advantage of this and register
111             * a C function in the table with the address of some structure containing data about
112             * what to clean up on exit\&.
113             * In the case of a function that takes no arguments, it will simply be ignore within the
114             * function itself\&. No worries\&.
115             **/
116             (*__atexit_funcs[i]\&.destructor_func)(__atexit_funcs[i]\&.obj_ptr);
117             __atexit_funcs[i]\&.destructor_func = 0;
118             
119             /*
120             * Notice that we didn't decrement __atexit_func_count: this is because this algorithm
121             * requires patching to deal with the FIXME outlined above\&.
122             **/
123         };
124     };
125 }
.fi

.PP
References \fB__atexit_func_count\fP, \fB__atexit_funcs\fP, and \fBessential::atexit_func_entry_t::destructor_func\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for OSOS - Documentation from the source code\&.
