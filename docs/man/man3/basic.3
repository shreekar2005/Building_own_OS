.TH "basic" 3 "Fri Oct 24 2025 10:32:01" "OSOS - Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
basic
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB__clearScreen\fP ()"
.br
.RI "Clears the entire text mode screen and resets the cursor to (0,0)\&. "
.ti -1c
.RI "void \fB__printMemoryMap\fP (multiboot_info_t *mbi)"
.br
.RI "Prints the system memory map provided by the Multiboot bootloader\&. "
.ti -1c
.RI "void \fBdisable_cursor\fP ()"
.br
.RI "Disables the text mode cursor\&. "
.ti -1c
.RI "void \fBenable_cursor\fP (uint8_t cursor_start, uint8_t cursor_end)"
.br
.RI "Enables the text mode cursor and sets its shape\&. "
.ti -1c
.RI "int \fBprintf\fP (const char *format,\&.\&.\&.)"
.br
.RI "A custom implementation of the standard printf function for writing to VGA text mode memory\&. "
.ti -1c
.RI "void \fBupdate_cursor\fP (int x, int y)"
.br
.RI "Updates the position of the text mode cursor\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "void basic::__clearScreen ()"

.PP
Clears the entire text mode screen and resets the cursor to (0,0)\&. 
.PP
Definition at line \fB128\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
129 {
130     unsigned short *video_memory = (unsigned short *)0xb8000;
131     unsigned short blank = (0x07 << 8) | ' ';
132     int screenSize = MAGIC_WIDTH * MAGIC_HEIGHT;
133 
134     for (int i = 0; i < screenSize; i++)
135     {
136         video_memory[i] = blank;
137     }
138 
139     cursor_x_ = 0;
140     cursor_y_ = 0;
141 }
.fi

.PP
References \fBcursor_x_\fP, \fBcursor_y_\fP, \fBMAGIC_HEIGHT\fP, and \fBMAGIC_WIDTH\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void basic::__printMemoryMap (multiboot_info_t * mbi)"

.PP
Prints the system memory map provided by the Multiboot bootloader\&. 
.PP
\fBParameters\fP
.RS 4
\fImbi\fP Pointer to the Multiboot information structure\&. 
.RE
.PP

.PP
Definition at line \fB5\fP of file \fBkmemory\&.cpp\fP\&..PP
.nf
6 {
7     // Check if the memory map flag is set (bit 6)
8     if (!(mbi\->flags & (1 << 6))) {
9         basic::printf("\\nError: Memory map not provided by bootloader\&.\\n");
10         return;
11     }
12 
13     basic::printf("\\n\-\-\- System Memory Map \-\-\-\\n");
14     
15     // Use uint64_t to correctly accumulate total memory size
16     uint64_t total_available_bytes = 0;
17     
18     // Use uintptr_t for pointer arithmetic to ensure portability
19     uintptr_t mmap_start = mbi\->mmap_addr;
20     uintptr_t mmap_end = mbi\->mmap_addr + mbi\->mmap_length;
21 
22     for (multiboot_memory_map_t *mmap = (multiboot_memory_map_t *)mmap_start;
23          (uintptr_t)mmap < mmap_end;
24          mmap = (multiboot_memory_map_t *)((uintptr_t)mmap + mmap\->size + sizeof(mmap\->size)))
25     {
26         const char *type_str;
27         switch (mmap\->type)
28         {
29         case MULTIBOOT_MEMORY_AVAILABLE:
30             type_str = "Available";
31             total_available_bytes += mmap\->len;
32             break;
33         case MULTIBOOT_MEMORY_RESERVED:
34             type_str = "Reserved";
35             break;
36         case MULTIBOOT_MEMORY_ACPI_RECLAIMABLE:
37             type_str = "ACPI Reclaimable";
38             break;
39         case MULTIBOOT_MEMORY_NVS:
40             type_str = "NVS";
41             break;
42         case MULTIBOOT_MEMORY_BADRAM:
43             type_str = "Bad RAM";
44             break;
45         default:
46             type_str = "Unknown";
47             break;
48         }
49 
50         // Use %#llx for 64\-bit hex values (address and length)
51         basic::printf("Addr: %#llx | Len: %\&.2fKB | Type: %s\\n", mmap\->addr, mmap\->len/1024\&.0, type_str);
52     }
53     
54     // Use floating point for the final calculation and display
55     double total_mb = total_available_bytes / 1024\&.0;
56     basic::printf("Total available memory: %\&.2f KB\\n\\n", total_mb);
57 }
.fi

.PP
References \fBMULTIBOOT_MEMORY_ACPI_RECLAIMABLE\fP, \fBMULTIBOOT_MEMORY_AVAILABLE\fP, \fBMULTIBOOT_MEMORY_BADRAM\fP, \fBMULTIBOOT_MEMORY_NVS\fP, \fBMULTIBOOT_MEMORY_RESERVED\fP, and \fBprintf()\fP\&.
.SS "void basic::disable_cursor ()"

.PP
Disables the text mode cursor\&. 
.PP
Definition at line \fB42\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
42                            {
43     vgaIndexPort\&.write(0x0A);
44     vgaDataPort\&.write(0x20);
45 }
.fi

.PP
References \fBvgaDataPort\fP, \fBvgaIndexPort\fP, and \fBhardware_communication::Port8Bit::write()\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void basic::enable_cursor (uint8_t cursor_start, uint8_t cursor_end)"

.PP
Enables the text mode cursor and sets its shape\&. 
.PP
\fBParameters\fP
.RS 4
\fIcursor_start\fP The starting scanline for the cursor block\&. 
.br
\fIcursor_end\fP The ending scanline for the cursor block\&. 
.RE
.PP

.PP
Definition at line \fB20\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
20                                                                   {
21     vgaIndexPort\&.write(0x0A);
22     vgaDataPort\&.write((vgaDataPort\&.read() & 0xC0) | cursor_start);
23     
24     vgaIndexPort\&.write(0x0B);
25     vgaDataPort\&.write((vgaDataPort\&.read() & 0xE0) | cursor_end);
26 }
.fi

.PP
References \fBhardware_communication::Port8Bit::read()\fP, \fBvgaDataPort\fP, \fBvgaIndexPort\fP, and \fBhardware_communication::Port8Bit::write()\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "int basic::printf (const char * format,  \&.\&.\&.)"

.PP
A custom implementation of the standard printf function for writing to VGA text mode memory\&. 
.IP "\(bu" 2
This function formats a string and prints it to the screen, handling various format specifiers, flags, width, precision, and length modifiers\&. It returns the total number of characters written\&.
.IP "\(bu" 2
\fBParameters\fP
.RS 4
\fIformat\fP The format string\&. 
.br
\fI\&.\&.\&.\fP Variable arguments corresponding to the format specifiers\&.
.RE
.PP

.IP "\(bu" 2
\fBReturns\fP
.RS 4
The total number of characters written to the screen\&.
.RE
.PP

.IP "\(bu" 2

.PP
.PP
Supported Format Specifiers: c - Character s - String d, i - Signed decimal integer u - Unsigned decimal integer f - Floating point number (double) x - Unsigned hexadecimal integer (lowercase) X - Unsigned hexadecimal integer (uppercase) b - Unsigned binary integer o - Unsigned octal integer p - Pointer address %% - A literal '' character
.IP "\(bu" 2
Supported Flags: '#' - Alternative form (e\&.g\&., 0x for hex, 0 for octal)\&. '0' - Zero-padding for width\&.
.IP "\(bu" 2
Supported Width: A number after '' specifies the minimum field width (e\&.g\&., %10d)\&.
.IP "\(bu" 2
Supported Precision: A period followed by a number specifies precision (e\&.g\&., %\&.4f, %\&.8X)\&. For integers, this specifies the minimum number of digits to print\&.
.IP "\(bu" 2
Supported Length Modifiers: h - short int (for d, i, u, x, X, o, b) hh - signed/unsigned char (for d, i, u, x, X, o, b) l - long int ll - long long int 
.PP

.PP
Definition at line \fB306\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
307 {
308     int chars_written = 0;
309 
310     va_list args;
311     va_start(args, format);
312 
313     char buffer[128];
314     char char_str[2] = {0, 0};
315 
316     for (int i = 0; format[i] != '\\0'; i++)
317     {
318         if (format[i] == '%')
319         {
320             i++;
321             
322             int use_alternative_form = 0;
323             int zero_pad = 0;
324             int width = 0;
325             int precision = \-1;
326             
327             // 1\&. Flags
328             // A boolean is clearer than using a while loop here
329             if (format[i] == '#') {
330                 use_alternative_form = 1;
331                 i++;
332             }
333             if (format[i] == '0') {
334                 zero_pad = 1;
335                 i++;
336             }
337 
338             // 2\&. Width
339             while (format[i] >= '0' && format[i] <= '9') {
340                 width = width * 10 + (format[i] \- '0');
341                 i++;
342             }
343 
344             // 3\&. Precision
345             if (format[i] == '\&.') {
346                 i++;
347                 precision = 0;
348                 while (format[i] >= '0' && format[i] <= '9') {
349                     precision = precision * 10 + (format[i] \- '0');
350                     i++;
351                 }
352                 zero_pad = 0;
353             }
354 
355             // 4\&. Length Modifiers
356             int is_long = 0, is_long_long = 0, is_short = 0, is_char = 0;
357             if (format[i] == 'l') {
358                 is_long = 1; i++;
359                 if (format[i] == 'l') { is_long_long = 1; is_long = 0; i++; }
360             } else if (format[i] == 'h') {
361                 is_short = 1; i++;
362                 if (format[i] == 'h') { is_char = 1; is_short = 0; i++; }
363             }
364 
365             // \-\-\- Handle Specifiers \-\-\-
366             switch (format[i])
367             {
368                 case 'c':
369                     char_str[0] = (char)va_arg(args, int);
370                     printCharStr(char_str);
371                     chars_written++;
372                     break;
373                 case 's':
374                 {
375                     const char *str = va_arg(args, char *);
376                     if (!str) {
377                         str = "(null)";
378                     }
379                     int len = 0;
380                     while (str[len]) {
381                         len++;
382                     }
383                     printCharStr(str);
384                     chars_written += len;
385                     break;
386                 }
387                 case 'f':
388                 {
389                     doubleToString(va_arg(args, double), buffer, precision);
390                     int len = 0;
391                     while(buffer[len]) {
392                         len++;
393                     }
394                     printCharStr(buffer);
395                     chars_written += len;
396                     break;
397                 }
398                 case 'd': case 'i': case 'u': case 'x': case 'X': case 'b': case 'o':
399                 {
400                     unsigned long long val;
401                     int base = 10;
402                     int uppercase = 0;
403                     char sign_char = 0;
404 
405                     if (format[i] == 'd' || format[i] == 'i') {
406                         long long signed_val;
407                         if (is_long_long) signed_val = va_arg(args, long long);
408                         else if (is_long) signed_val = va_arg(args, long);
409                         else if (is_char) signed_val = (signed char)va_arg(args, int);
410                         else if (is_short) signed_val = (short)va_arg(args, int);
411                         else signed_val = va_arg(args, int);
412                         
413                         if (signed_val < 0) {
414                             sign_char = '\-';
415                             val = \-signed_val;
416                         } else {
417                             val = signed_val;
418                         }
419                     } else {
420                         if (is_long_long) val = va_arg(args, unsigned long long);
421                         else if (is_long) val = va_arg(args, unsigned long);
422                         else if (is_char) val = (unsigned char)va_arg(args, unsigned int);
423                         else if (is_short) val = (unsigned short)va_arg(args, unsigned int);
424                         else val = va_arg(args, unsigned int);
425                     }
426 
427                     switch(format[i]) {
428                         case 'x': base = 16; break;
429                         case 'X': base = 16; uppercase = 1; break;
430                         case 'b': base = 2; break;
431                         case 'o': base = 8; break;
432                     }
433                     
434                     ullToString(val, buffer, base, 0, uppercase);
435 
436                     const char* prefix = "";
437                     if (use_alternative_form && val != 0) {
438                         switch(format[i]) {
439                             case 'x': prefix = "0x"; break;
440                             case 'X': prefix = "0X"; break;
441                             case 'b': prefix = "0b"; break;
442                             case 'o': prefix = "0"; break;
443                         }
444                     }
445                     
446                     int num_len = 0; while(buffer[num_len]) num_len++;
447                     int prefix_len = 0; while(prefix[prefix_len]) prefix_len++;
448                     
449                     int precision_pads = (precision > num_len) ? (precision \- num_len) : 0;
450                     int total_len = num_len + (sign_char ? 1 : 0) + prefix_len + precision_pads;
451                     int width_pads = (width > total_len) ? (width \- total_len) : 0;
452                     
453                     chars_written += width_pads + total_len;
454 
455                     if (!zero_pad && width_pads > 0) {
456                         for (int j = 0; j < width_pads; j++) printCharStr(" ");
457                     }
458                     if (sign_char) {
459                         char_str[0] = sign_char; printCharStr(char_str);
460                     }
461                     if (prefix_len > 0) printCharStr(prefix);
462                     if (zero_pad && width_pads > 0) {
463                         for (int j = 0; j < width_pads; j++) printCharStr("0");
464                     }
465                     if (precision_pads > 0) {
466                         for (int j = 0; j < precision_pads; j++) printCharStr("0");
467                     }
468                     printCharStr(buffer);
469                     break;
470                 }
471                 
472                 case 'p':
473                 {
474                     printCharStr("0x");
475                     int hex_digits = sizeof(uintptr_t) * 2;
476                     printHex((uintptr_t)va_arg(args, void *), hex_digits);
477                     chars_written += 2 + hex_digits;
478                     break;
479                 }
480                 case '%':
481                     printCharStr("%");
482                     chars_written++;
483                     break;
484                 default:
485                     printCharStr("%");
486                     char_str[0] = format[i];
487                     printCharStr(char_str);
488                     chars_written += 2;
489                     break;
490             }
491         }
492         else
493         {
494             char_str[0] = format[i];
495             printCharStr(char_str);
496             chars_written++;
497         }
498     }
499     va_end(args);
500     update_cursor(cursor_x_, cursor_y_);
501     return chars_written;
502 }
.fi

.PP
References \fBbase\fP, \fBcursor_x_\fP, \fBcursor_y_\fP, \fBdoubleToString()\fP, \fBlen\fP, \fBprintCharStr()\fP, \fBprintHex()\fP, \fBullToString()\fP, and \fBupdate_cursor()\fP\&.
.PP
Referenced by \fB__printMemoryMap()\fP, \fBhardware_communication::InterruptManager::activate()\fP, \fBdriver::KeyboardDriver::activate()\fP, \fBdriver::MouseDriver::activate()\fP, \fBhardware_communication::InterruptManager::deactivate()\fP, \fBhardware_communication::InterruptManager::handleInterrupt()\fP, \fBessential::GDT::installTable()\fP, \fBhardware_communication::InterruptManager::installTable()\fP, \fBkernelMain()\fP, \fBKeyboardEventHandler_for_kernel::onKeyDown()\fP, \fBessential::GDT::printLoadedTable()\fP, \fBhardware_communication::InterruptManager::printLoadedTable()\fP, \fBessential::GDT::printLoadedTableHeader()\fP, and \fBhardware_communication::InterruptManager::printLoadedTableHeader()\fP\&.
.SS "void basic::update_cursor (int x, int y)"

.PP
Updates the position of the text mode cursor\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The new x-coordinate (column)\&. 
.br
\fIy\fP The new y-coordinate (row)\&. 
.RE
.PP

.PP
Definition at line \fB31\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
31                                       {
32     cursor_x_=x;
33     cursor_y_=y;
34     uint16_t pos = y * 80 + x;
35     vgaIndexPort\&.write(0x0F);
36     vgaDataPort\&.write((uint8_t)(pos & 0xFF));
37     vgaIndexPort\&.write(0x0E);
38     vgaDataPort\&.write((uint8_t)((pos >> 8) & 0xFF));
39 }
.fi

.PP
References \fBcursor_x_\fP, \fBcursor_y_\fP, \fBvgaDataPort\fP, \fBvgaIndexPort\fP, and \fBhardware_communication::Port8Bit::write()\fP\&.
.PP
Referenced by \fBMouseEventHandler_for_kernel::onMouseDown()\fP, and \fBprintf()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for OSOS - Documentation from the source code\&.
