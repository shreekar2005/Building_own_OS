.TH "basic" 3 "Fri Oct 24 2025 00:21:12" "OSOS - Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
basic
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB__clearScreen\fP ()"
.br
.ti -1c
.RI "void \fB__printMemoryMap\fP (multiboot_info_t *mbi)"
.br
.ti -1c
.RI "void \fBdisable_cursor\fP ()"
.br
.ti -1c
.RI "void \fBenable_cursor\fP (uint8_t cursor_start, uint8_t cursor_end)"
.br
.ti -1c
.RI "int \fBprintf\fP (const char *format,\&.\&.\&.)"
.br
.RI "A custom implementation of the standard printf function for writing to VGA text mode memory\&. "
.ti -1c
.RI "void \fBupdate_cursor\fP (int x, int y)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void basic::__clearScreen ()"

.PP
Definition at line \fB118\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
119 {
120     unsigned short *video_memory = (unsigned short *)0xb8000;
121     unsigned short blank = (0x07 << 8) | ' ';
122     int screenSize = MAGIC_WIDTH * MAGIC_HEIGHT;
123 
124     for (int i = 0; i < screenSize; i++)
125     {
126         video_memory[i] = blank;
127     }
128 
129     cursor_x_ = 0;
130     cursor_y_ = 0;
131 }
.fi

.PP
References \fBcursor_x_\fP, \fBcursor_y_\fP, \fBMAGIC_HEIGHT\fP, and \fBMAGIC_WIDTH\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void basic::__printMemoryMap (multiboot_info_t * mbi)"

.PP
Definition at line \fB3\fP of file \fBkmemory\&.cpp\fP\&..PP
.nf
4 {
5     // Check if the memory map flag is set (bit 6)
6     if (!(mbi\->flags & (1 << 6))) {
7         basic::printf("\\nError: Memory map not provided by bootloader\&.\\n");
8         return;
9     }
10 
11     basic::printf("\\n\-\-\- System Memory Map \-\-\-\\n");
12     
13     // Use uint64_t to correctly accumulate total memory size
14     uint64_t total_available_bytes = 0;
15     
16     // Use uintptr_t for pointer arithmetic to ensure portability
17     uintptr_t mmap_start = mbi\->mmap_addr;
18     uintptr_t mmap_end = mbi\->mmap_addr + mbi\->mmap_length;
19 
20     for (multiboot_memory_map_t *mmap = (multiboot_memory_map_t *)mmap_start;
21          (uintptr_t)mmap < mmap_end;
22          mmap = (multiboot_memory_map_t *)((uintptr_t)mmap + mmap\->size + sizeof(mmap\->size)))
23     {
24         const char *type_str;
25         switch (mmap\->type)
26         {
27         case MULTIBOOT_MEMORY_AVAILABLE:
28             type_str = "Available";
29             total_available_bytes += mmap\->len;
30             break;
31         case MULTIBOOT_MEMORY_RESERVED:
32             type_str = "Reserved";
33             break;
34         case MULTIBOOT_MEMORY_ACPI_RECLAIMABLE:
35             type_str = "ACPI Reclaimable";
36             break;
37         case MULTIBOOT_MEMORY_NVS:
38             type_str = "NVS";
39             break;
40         case MULTIBOOT_MEMORY_BADRAM:
41             type_str = "Bad RAM";
42             break;
43         default:
44             type_str = "Unknown";
45             break;
46         }
47 
48         // Use %#llx for 64\-bit hex values (address and length)
49         basic::printf("Addr: %#llx | Len: %\&.2fKB | Type: %s\\n", mmap\->addr, mmap\->len/1024\&.0, type_str);
50     }
51     
52     // Use floating point for the final calculation and display
53     double total_mb = total_available_bytes / 1024\&.0;
54     basic::printf("Total available memory: %\&.2f KB\\n\\n", total_mb);
55 }
.fi

.PP
References \fBMULTIBOOT_MEMORY_ACPI_RECLAIMABLE\fP, \fBMULTIBOOT_MEMORY_AVAILABLE\fP, \fBMULTIBOOT_MEMORY_BADRAM\fP, \fBMULTIBOOT_MEMORY_NVS\fP, \fBMULTIBOOT_MEMORY_RESERVED\fP, and \fBprintf()\fP\&.
.SS "void basic::disable_cursor ()"

.PP
Definition at line \fB35\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
35                            {
36     vgaIndexPort\&.write(0x0A);
37     vgaDataPort\&.write(0x20);
38 }
.fi

.PP
References \fBvgaDataPort\fP, \fBvgaIndexPort\fP, and \fBhardware_communication::Port8Bit::write()\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "void basic::enable_cursor (uint8_t cursor_start, uint8_t cursor_end)"

.PP
Definition at line \fB17\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
17                                                                   {
18     vgaIndexPort\&.write(0x0A);
19     vgaDataPort\&.write((vgaDataPort\&.read() & 0xC0) | cursor_start);
20     
21     vgaIndexPort\&.write(0x0B);
22     vgaDataPort\&.write((vgaDataPort\&.read() & 0xE0) | cursor_end);
23 }
.fi

.PP
References \fBhardware_communication::Port8Bit::read()\fP, \fBvgaDataPort\fP, \fBvgaIndexPort\fP, and \fBhardware_communication::Port8Bit::write()\fP\&.
.PP
Referenced by \fBkernelMain()\fP\&.
.SS "int basic::printf (const char * format,  \&.\&.\&.)"

.PP
A custom implementation of the standard printf function for writing to VGA text mode memory\&. 
.IP "\(bu" 2
This function formats a string and prints it to the screen, handling various format specifiers, flags, width, precision, and length modifiers\&. It returns the total number of characters written\&.
.IP "\(bu" 2
\fBParameters\fP
.RS 4
\fIformat\fP The format string\&. 
.br
\fI\&.\&.\&.\fP Variable arguments corresponding to the format specifiers\&.
.RE
.PP

.IP "\(bu" 2
\fBReturns\fP
.RS 4
The total number of characters written to the screen\&.
.RE
.PP

.IP "\(bu" 2

.PP
.PP
Supported Format Specifiers: c - Character s - String d, i - Signed decimal integer u - Unsigned decimal integer f - Floating point number (double) x - Unsigned hexadecimal integer (lowercase) X - Unsigned hexadecimal integer (uppercase) b - Unsigned binary integer o - Unsigned octal integer p - Pointer address %% - A literal '' character
.IP "\(bu" 2
Supported Flags: '#' - Alternative form (e\&.g\&., 0x for hex, 0 for octal)\&. '0' - Zero-padding for width\&.
.IP "\(bu" 2
Supported Width: A number after '' specifies the minimum field width (e\&.g\&., %10d)\&.
.IP "\(bu" 2
Supported Precision: A period followed by a number specifies precision (e\&.g\&., %\&.4f, %\&.8X)\&. For integers, this specifies the minimum number of digits to print\&.
.IP "\(bu" 2
Supported Length Modifiers: h - short int (for d, i, u, x, X, o, b) hh - signed/unsigned char (for d, i, u, x, X, o, b) l - long int ll - long long int 
.PP

.PP
Definition at line \fB276\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
277 {
278     int chars_written = 0;
279 
280     va_list args;
281     va_start(args, format);
282 
283     char buffer[128];
284     char char_str[2] = {0, 0};
285 
286     for (int i = 0; format[i] != '\\0'; i++)
287     {
288         if (format[i] == '%')
289         {
290             i++;
291             
292             int use_alternative_form = 0;
293             int zero_pad = 0;
294             int width = 0;
295             int precision = \-1;
296             
297             // 1\&. Flags
298             // A boolean is clearer than using a while loop here
299             if (format[i] == '#') {
300                 use_alternative_form = 1;
301                 i++;
302             }
303             if (format[i] == '0') {
304                 zero_pad = 1;
305                 i++;
306             }
307 
308             // 2\&. Width
309             while (format[i] >= '0' && format[i] <= '9') {
310                 width = width * 10 + (format[i] \- '0');
311                 i++;
312             }
313 
314             // 3\&. Precision
315             if (format[i] == '\&.') {
316                 i++;
317                 precision = 0;
318                 while (format[i] >= '0' && format[i] <= '9') {
319                     precision = precision * 10 + (format[i] \- '0');
320                     i++;
321                 }
322                 zero_pad = 0;
323             }
324 
325             // 4\&. Length Modifiers
326             int is_long = 0, is_long_long = 0, is_short = 0, is_char = 0;
327             if (format[i] == 'l') {
328                 is_long = 1; i++;
329                 if (format[i] == 'l') { is_long_long = 1; is_long = 0; i++; }
330             } else if (format[i] == 'h') {
331                 is_short = 1; i++;
332                 if (format[i] == 'h') { is_char = 1; is_short = 0; i++; }
333             }
334 
335             // \-\-\- Handle Specifiers \-\-\-
336             switch (format[i])
337             {
338                 case 'c':
339                     char_str[0] = (char)va_arg(args, int);
340                     printCharStr(char_str);
341                     chars_written++;
342                     break;
343                 case 's':
344                 {
345                     const char *str = va_arg(args, char *);
346                     if (!str) {
347                         str = "(null)";
348                     }
349                     int len = 0;
350                     while (str[len]) {
351                         len++;
352                     }
353                     printCharStr(str);
354                     chars_written += len;
355                     break;
356                 }
357                 case 'f':
358                 {
359                     doubleToString(va_arg(args, double), buffer, precision);
360                     int len = 0;
361                     while(buffer[len]) {
362                         len++;
363                     }
364                     printCharStr(buffer);
365                     chars_written += len;
366                     break;
367                 }
368                 case 'd': case 'i': case 'u': case 'x': case 'X': case 'b': case 'o':
369                 {
370                     unsigned long long val;
371                     int base = 10;
372                     int uppercase = 0;
373                     char sign_char = 0;
374 
375                     if (format[i] == 'd' || format[i] == 'i') {
376                         long long signed_val;
377                         if (is_long_long) signed_val = va_arg(args, long long);
378                         else if (is_long) signed_val = va_arg(args, long);
379                         else if (is_char) signed_val = (signed char)va_arg(args, int);
380                         else if (is_short) signed_val = (short)va_arg(args, int);
381                         else signed_val = va_arg(args, int);
382                         
383                         if (signed_val < 0) {
384                             sign_char = '\-';
385                             val = \-signed_val;
386                         } else {
387                             val = signed_val;
388                         }
389                     } else {
390                         if (is_long_long) val = va_arg(args, unsigned long long);
391                         else if (is_long) val = va_arg(args, unsigned long);
392                         else if (is_char) val = (unsigned char)va_arg(args, unsigned int);
393                         else if (is_short) val = (unsigned short)va_arg(args, unsigned int);
394                         else val = va_arg(args, unsigned int);
395                     }
396 
397                     switch(format[i]) {
398                         case 'x': base = 16; break;
399                         case 'X': base = 16; uppercase = 1; break;
400                         case 'b': base = 2; break;
401                         case 'o': base = 8; break;
402                     }
403                     
404                     ullToString(val, buffer, base, 0, uppercase);
405 
406                     const char* prefix = "";
407                     if (use_alternative_form && val != 0) {
408                         switch(format[i]) {
409                             case 'x': prefix = "0x"; break;
410                             case 'X': prefix = "0X"; break;
411                             case 'b': prefix = "0b"; break;
412                             case 'o': prefix = "0"; break;
413                         }
414                     }
415                     
416                     int num_len = 0; while(buffer[num_len]) num_len++;
417                     int prefix_len = 0; while(prefix[prefix_len]) prefix_len++;
418                     
419                     int precision_pads = (precision > num_len) ? (precision \- num_len) : 0;
420                     int total_len = num_len + (sign_char ? 1 : 0) + prefix_len + precision_pads;
421                     int width_pads = (width > total_len) ? (width \- total_len) : 0;
422                     
423                     chars_written += width_pads + total_len;
424 
425                     if (!zero_pad && width_pads > 0) {
426                         for (int j = 0; j < width_pads; j++) printCharStr(" ");
427                     }
428                     if (sign_char) {
429                         char_str[0] = sign_char; printCharStr(char_str);
430                     }
431                     if (prefix_len > 0) printCharStr(prefix);
432                     if (zero_pad && width_pads > 0) {
433                         for (int j = 0; j < width_pads; j++) printCharStr("0");
434                     }
435                     if (precision_pads > 0) {
436                         for (int j = 0; j < precision_pads; j++) printCharStr("0");
437                     }
438                     printCharStr(buffer);
439                     break;
440                 }
441                 
442                 case 'p':
443                 {
444                     printCharStr("0x");
445                     int hex_digits = sizeof(uintptr_t) * 2;
446                     printHex((uintptr_t)va_arg(args, void *), hex_digits);
447                     chars_written += 2 + hex_digits;
448                     break;
449                 }
450                 case '%':
451                     printCharStr("%");
452                     chars_written++;
453                     break;
454                 default:
455                     printCharStr("%");
456                     char_str[0] = format[i];
457                     printCharStr(char_str);
458                     chars_written += 2;
459                     break;
460             }
461         }
462         else
463         {
464             char_str[0] = format[i];
465             printCharStr(char_str);
466             chars_written++;
467         }
468     }
469     va_end(args);
470     update_cursor(cursor_x_, cursor_y_);
471     return chars_written;
472 }
.fi

.PP
References \fBbase\fP, \fBcursor_x_\fP, \fBcursor_y_\fP, \fBdoubleToString()\fP, \fBlen\fP, \fBprintCharStr()\fP, \fBprintHex()\fP, \fBullToString()\fP, and \fBupdate_cursor()\fP\&.
.PP
Referenced by \fB__printMemoryMap()\fP, \fBhardware_communication::InterruptManager::activate()\fP, \fBdriver::KeyboardDriver::activate()\fP, \fBdriver::MouseDriver::activate()\fP, \fBhardware_communication::InterruptManager::deactivate()\fP, \fBhardware_communication::InterruptManager::handleInterrupt()\fP, \fBessential::GDT::installTable()\fP, \fBhardware_communication::InterruptManager::installTable()\fP, \fBkernelMain()\fP, \fBKeyboardEventHandler_for_kernel::onKeyDown()\fP, \fBessential::GDT::printLoadedTable()\fP, \fBhardware_communication::InterruptManager::printLoadedTable()\fP, \fBessential::GDT::printLoadedTableHeader()\fP, and \fBhardware_communication::InterruptManager::printLoadedTableHeader()\fP\&.
.SS "void basic::update_cursor (int x, int y)"

.PP
Definition at line \fB25\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
25                                       {
26     cursor_x_=x;
27     cursor_y_=y;
28     uint16_t pos = y * 80 + x;
29     vgaIndexPort\&.write(0x0F);
30     vgaDataPort\&.write((uint8_t)(pos & 0xFF));
31     vgaIndexPort\&.write(0x0E);
32     vgaDataPort\&.write((uint8_t)((pos >> 8) & 0xFF));
33 }
.fi

.PP
References \fBcursor_x_\fP, \fBcursor_y_\fP, \fBvgaDataPort\fP, \fBvgaIndexPort\fP, and \fBhardware_communication::Port8Bit::write()\fP\&.
.PP
Referenced by \fBMouseEventHandler_for_kernel::onMouseDown()\fP, and \fBprintf()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for OSOS - Documentation from the source code\&.
