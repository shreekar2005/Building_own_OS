.TH "/home/shreekar/Desktop/Building_own_OS/OSOS/libk_src/basic/kiostream.cpp" 3 "Fri Oct 24 2025 10:32:01" "OSOS - Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/shreekar/Desktop/Building_own_OS/OSOS/libk_src/basic/kiostream.cpp
.SH SYNOPSIS
.br
.PP
\fC#include 'basic/kiostream\&.hpp'\fP
.br
\fC#include 'driver/kmouse\&.hpp'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMAGIC_HEIGHT\fP   25"
.br
.ti -1c
.RI "#define \fBMAGIC_WIDTH\fP   80"
.br
.ti -1c
.RI "#define \fBTAB_WIDTH\fP   4"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBdoubleToString\fP (double d, char *buffer, int precision)"
.br
.RI "Converts a double-precision floating point number to a string\&. "
.ti -1c
.RI "static double \fBpower\fP (double \fBbase\fP, int exp)"
.br
.RI "Calculates the power of a number\&. "
.ti -1c
.RI "static void \fBprintCharStr\fP (const char *str)"
.br
.RI "Internal function to print a null-terminated string to video memory\&. "
.ti -1c
.RI "static void \fBprintHex\fP (uintptr_t n, int digits)"
.br
.RI "Prints a hexadecimal number with leading zeros\&. "
.ti -1c
.RI "static void \fBreverse\fP (char *str, int length)"
.br
.RI "Reverses a string in place\&. "
.ti -1c
.RI "static void \fBullToString\fP (unsigned long long n, char *buffer, int \fBbase\fP, int is_signed, int uppercase)"
.br
.RI "Converts an unsigned long long integer to a string\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static int \fBcursor_x_\fP = 0"
.br
.ti -1c
.RI "static int \fBcursor_y_\fP = 0"
.br
.ti -1c
.RI "static \fBhardware_communication::Port8Bit\fP \fBvgaDataPort\fP (0x3D5)"
.br
.ti -1c
.RI "static \fBhardware_communication::Port8Bit\fP \fBvgaIndexPort\fP (0x3D4)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define MAGIC_HEIGHT   25"

.PP
Definition at line \fB8\fP of file \fBkiostream\&.cpp\fP\&.
.SS "#define MAGIC_WIDTH   80"

.PP
Definition at line \fB7\fP of file \fBkiostream\&.cpp\fP\&.
.SS "#define TAB_WIDTH   4"

.PP
Definition at line \fB9\fP of file \fBkiostream\&.cpp\fP\&.
.SH "Function Documentation"
.PP 
.SS "static void doubleToString (double d, char * buffer, int precision)\fC [static]\fP"

.PP
Converts a double-precision floating point number to a string\&. 
.PP
\fBParameters\fP
.RS 4
\fId\fP The double to convert\&. 
.br
\fIbuffer\fP The output buffer to store the string\&. 
.br
\fIprecision\fP The number of digits after the decimal point\&. 
.RE
.PP

.PP
Definition at line \fB216\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
217 {
218     if (precision < 0)
219         precision = 6;
220     char *ptr = buffer;
221 
222     if (d < 0)
223     {
224         *ptr++ = '\-';
225         d = \-d;
226     }
227     
228     unsigned long long int_part = (unsigned long long)d;
229     double frac_part = d \- (double)int_part;
230 
231     ullToString(int_part, ptr, 10, 0, 0);
232     while (*ptr) ptr++;
233 
234     *ptr++ = '\&.';
235     
236     unsigned long long frac_as_ull = (unsigned long long)(frac_part * power(10, precision) + 0\&.5);
237     
238     char frac_buffer[32];
239     ullToString(frac_as_ull, frac_buffer, 10, 0, 0);
240 
241     int frac_len = 0;
242     while(frac_buffer[frac_len] != '\\0') frac_len++;
243     
244     int padding = precision \- frac_len;
245     for (int i = 0; i < padding; i++)
246         *ptr++ = '0';
247     
248     char* frac_ptr = frac_buffer;
249     while(*frac_ptr) *ptr++ = *frac_ptr++;
250 
251     *ptr = '\\0';
252 }
.fi

.PP
References \fBpower()\fP, and \fBullToString()\fP\&.
.PP
Referenced by \fBbasic::printf()\fP\&.
.SS "static double power (double base, int exp)\fC [static]\fP"

.PP
Calculates the power of a number\&. 
.PP
\fBParameters\fP
.RS 4
\fIbase\fP The base\&. 
.br
\fIexp\fP The exponent\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The result of base raised to the power of exp\&. 
.RE
.PP

.PP
Definition at line \fB204\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
205 {
206     double res = 1\&.0;
207     for (int i = 0; i < exp; ++i)
208         res *= base;
209     return res;
210 }
.fi

.PP
References \fBbase\fP\&.
.PP
Referenced by \fBdoubleToString()\fP\&.
.SS "static void printCharStr (const char * str)\fC [static]\fP"

.PP
Internal function to print a null-terminated string to video memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to print\&. 
.RE
.PP

.PP
Definition at line \fB50\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
51 {
52     uint16_t *video_memory = (uint16_t *)0xb8000;
53     // FOR TEXT : Attribute for Gray\-White (0x7) text on a Black (0x0) background (last 2 bytes (LSBs) are not used for color)\&.
54     const uint16_t color_attribute = 0x0700;
55 
56     // \-\-\- MOUSE\-SAFE PRINTING: remove mouse \-\-\-
57     int mouse_offset = driver::MouseDriver::__mouse_y_ * MAGIC_WIDTH + driver::MouseDriver::__mouse_x_;
58     if(mouse_offset>=0) video_memory[mouse_offset] = driver::MouseDriver::old_char_under_mouse_pointer;
59 
60 
61     for (int i = 0; str[i] != '\\0'; i++)
62     {
63         if (str[i] == '\\n')
64         {
65             cursor_y_++;
66             cursor_x_ = 0;
67         }
68         else if (str[i] == '\\b')
69         {
70             if (cursor_x_ > 0)
71             {
72                 cursor_x_\-\-;
73                 int offset = cursor_y_ * MAGIC_WIDTH + cursor_x_;
74                 video_memory[offset] = color_attribute | ' ';
75             }
76         }
77         else if (str[i] == '\\r')
78         {
79             cursor_x_ = 0;
80         }
81         else if (str[i] == '\\t')
82         {
83             cursor_x_ = cursor_x_ + (TAB_WIDTH \- (cursor_x_ % TAB_WIDTH));
84         }
85         else
86         {
87             int offset = cursor_y_ * MAGIC_WIDTH + cursor_x_;
88             video_memory[offset] = color_attribute | str[i];
89             cursor_x_++;
90         }
91 
92         if (cursor_x_ >= MAGIC_WIDTH)
93         {
94             cursor_y_++;
95             cursor_x_ = 0;
96         }
97 
98         if (cursor_y_ >= MAGIC_HEIGHT)
99         {
100             for (int y = 0; y < (MAGIC_HEIGHT \- 1); y++)
101             {
102                 for (int x = 0; x < MAGIC_WIDTH; x++)
103                 {
104                     int current_offset = y * MAGIC_WIDTH + x;
105                     int next_line_offset = (y + 1) * MAGIC_WIDTH + x;
106                     video_memory[current_offset] = video_memory[next_line_offset];
107                 }
108             }
109 
110             int last_line_offset_start = (MAGIC_HEIGHT \- 1) * MAGIC_WIDTH;
111             for (int x = 0; x < MAGIC_WIDTH; x++)
112             {
113                 video_memory[last_line_offset_start + x] = color_attribute | ' ';
114             }
115 
116             cursor_y_ = MAGIC_HEIGHT \- 1;
117             cursor_x_ = 0;
118         }
119     }
120 
121     // \-\-\- MOUSE\-SAFE PRINTING: add mouse again\-\-\-
122     driver::MouseDriver::old_char_under_mouse_pointer = video_memory[mouse_offset];
123     if(mouse_offset>=0) video_memory[mouse_offset] = driver::MouseDriver::mouse_block_video_mem_value(driver::MouseDriver::old_char_under_mouse_pointer, MOUSE_POINTER_COLOR);
124 
125 }
.fi

.PP
References \fBdriver::MouseDriver::__mouse_x_\fP, \fBdriver::MouseDriver::__mouse_y_\fP, \fBcursor_x_\fP, \fBcursor_y_\fP, \fBMAGIC_HEIGHT\fP, \fBMAGIC_WIDTH\fP, \fBdriver::MouseDriver::mouse_block_video_mem_value()\fP, \fBMOUSE_POINTER_COLOR\fP, \fBdriver::MouseDriver::old_char_under_mouse_pointer\fP, and \fBTAB_WIDTH\fP\&.
.PP
Referenced by \fBbasic::printf()\fP, and \fBprintHex()\fP\&.
.SS "static void printHex (uintptr_t n, int digits)\fC [static]\fP"

.PP
Prints a hexadecimal number with leading zeros\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP The number to print\&. 
.br
\fIdigits\fP The total number of digits to print (padded with zeros)\&. 
.RE
.PP

.PP
Definition at line \fB257\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
257                                               {
258     char buffer[32];
259     ullToString(n, buffer, 16, 0, 1); // Use uppercase for pointers typically
260 
261     int len = 0;
262     while (buffer[len] != '\\0') {
263         len++;
264     }
265 
266     for (int i = 0; i < digits \- len; i++) {
267         printCharStr("0");
268     }
269     printCharStr(buffer);
270 }
.fi

.PP
References \fBlen\fP, \fBprintCharStr()\fP, and \fBullToString()\fP\&.
.PP
Referenced by \fBbasic::printf()\fP\&.
.SS "static void reverse (char * str, int length)\fC [static]\fP"

.PP
Reverses a string in place\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to reverse\&. 
.br
\fIlength\fP The length of the string\&. 
.RE
.PP

.PP
Definition at line \fB146\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
147 {
148     int start = 0;
149     int end = length \- 1;
150     while (start < end)
151     {
152         char temp = str[start];
153         str[start] = str[end];
154         str[end] = temp;
155         start++;
156         end\-\-;
157     }
158 }
.fi

.PP
Referenced by \fBullToString()\fP\&.
.SS "static void ullToString (unsigned long long n, char * buffer, int base, int is_signed, int uppercase)\fC [static]\fP"

.PP
Converts an unsigned long long integer to a string\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP The number to convert\&. 
.br
\fIbuffer\fP The output buffer to store the string\&. 
.br
\fIbase\fP The numerical base (e\&.g\&., 2, 8, 10, 16)\&. 
.br
\fIis_signed\fP Whether the original number was signed (for handling negative sign)\&. 
.br
\fIuppercase\fP Whether to use uppercase letters for bases > 10\&. 
.RE
.PP

.PP
Definition at line \fB166\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
167 {
168     int i = 0;
169     int isNegative = 0;
170 
171     if (n == 0)
172     {
173         buffer[i++] = '0';
174         buffer[i] = '\\0';
175         return;
176     }
177 
178     if (is_signed && (long long)n < 0)
179     {
180         isNegative = 1;
181         n = \-(long long)n;
182     }
183 
184     while (n != 0)
185     {
186         int rem = n % base;
187         buffer[i++] = (rem > 9) ? ((rem \- 10) + (uppercase ? 'A' : 'a')) : (rem + '0');
188         n = n / base;
189     }
190 
191     if (isNegative)
192     {
193         buffer[i++] = '\-';
194     }
195 
196     buffer[i] = '\\0';
197     reverse(buffer, i);
198 }
.fi

.PP
References \fBbase\fP, and \fBreverse()\fP\&.
.PP
Referenced by \fBdoubleToString()\fP, \fBbasic::printf()\fP, and \fBprintHex()\fP\&.
.SH "Variable Documentation"
.PP 
.SS "int cursor_x_ = 0\fC [static]\fP"

.PP
Definition at line \fB4\fP of file \fBkiostream\&.cpp\fP\&.
.PP
Referenced by \fBbasic::__clearScreen()\fP, \fBprintCharStr()\fP, \fBbasic::printf()\fP, and \fBbasic::update_cursor()\fP\&.
.SS "int cursor_y_ = 0\fC [static]\fP"

.PP
Definition at line \fB5\fP of file \fBkiostream\&.cpp\fP\&.
.PP
Referenced by \fBbasic::__clearScreen()\fP, \fBprintCharStr()\fP, \fBbasic::printf()\fP, and \fBbasic::update_cursor()\fP\&.
.SS "\fBhardware_communication::Port8Bit\fP vgaDataPort(0x3D5) (0x3D5)\fC [static]\fP"

.PP
Referenced by \fBbasic::disable_cursor()\fP, \fBbasic::enable_cursor()\fP, and \fBbasic::update_cursor()\fP\&.
.SS "\fBhardware_communication::Port8Bit\fP vgaIndexPort(0x3D4) (0x3D4)\fC [static]\fP"

.PP
Referenced by \fBbasic::disable_cursor()\fP, \fBbasic::enable_cursor()\fP, and \fBbasic::update_cursor()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for OSOS - Documentation from the source code\&.
