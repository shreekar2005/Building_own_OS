.TH "libk_src/basic/kiostream.cpp" 3 "Fri Oct 24 2025 00:21:12" "OSOS - Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libk_src/basic/kiostream.cpp
.SH SYNOPSIS
.br
.PP
\fC#include 'basic/kiostream\&.hpp'\fP
.br
\fC#include 'driver/kmouse\&.hpp'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMAGIC_HEIGHT\fP   25"
.br
.ti -1c
.RI "#define \fBMAGIC_WIDTH\fP   80"
.br
.ti -1c
.RI "#define \fBTAB_WIDTH\fP   4"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBdoubleToString\fP (double d, char *buffer, int precision)"
.br
.ti -1c
.RI "static double \fBpower\fP (double \fBbase\fP, int exp)"
.br
.ti -1c
.RI "static void \fBprintCharStr\fP (const char *str)"
.br
.ti -1c
.RI "static void \fBprintHex\fP (uintptr_t n, int digits)"
.br
.ti -1c
.RI "static void \fBreverse\fP (char *str, int length)"
.br
.ti -1c
.RI "static void \fBullToString\fP (unsigned long long n, char *buffer, int \fBbase\fP, int is_signed, int uppercase)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static int \fBcursor_x_\fP = 0"
.br
.ti -1c
.RI "static int \fBcursor_y_\fP = 0"
.br
.ti -1c
.RI "static \fBhardware_communication::Port8Bit\fP \fBvgaDataPort\fP (0x3D5)"
.br
.ti -1c
.RI "static \fBhardware_communication::Port8Bit\fP \fBvgaIndexPort\fP (0x3D4)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define MAGIC_HEIGHT   25"

.PP
Definition at line \fB8\fP of file \fBkiostream\&.cpp\fP\&.
.SS "#define MAGIC_WIDTH   80"

.PP
Definition at line \fB7\fP of file \fBkiostream\&.cpp\fP\&.
.SS "#define TAB_WIDTH   4"

.PP
Definition at line \fB9\fP of file \fBkiostream\&.cpp\fP\&.
.SH "Function Documentation"
.PP 
.SS "static void doubleToString (double d, char * buffer, int precision)\fC [static]\fP"

.PP
Definition at line \fB189\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
190 {
191     if (precision < 0)
192         precision = 6;
193     char *ptr = buffer;
194 
195     if (d < 0)
196     {
197         *ptr++ = '\-';
198         d = \-d;
199     }
200     
201     unsigned long long int_part = (unsigned long long)d;
202     double frac_part = d \- (double)int_part;
203 
204     ullToString(int_part, ptr, 10, 0, 0);
205     while (*ptr) ptr++;
206 
207     *ptr++ = '\&.';
208     
209     unsigned long long frac_as_ull = (unsigned long long)(frac_part * power(10, precision) + 0\&.5);
210     
211     char frac_buffer[32];
212     ullToString(frac_as_ull, frac_buffer, 10, 0, 0);
213 
214     int frac_len = 0;
215     while(frac_buffer[frac_len] != '\\0') frac_len++;
216     
217     int padding = precision \- frac_len;
218     for (int i = 0; i < padding; i++)
219         *ptr++ = '0';
220     
221     char* frac_ptr = frac_buffer;
222     while(*frac_ptr) *ptr++ = *frac_ptr++;
223 
224     *ptr = '\\0';
225 }
.fi

.PP
References \fBpower()\fP, and \fBullToString()\fP\&.
.PP
Referenced by \fBbasic::printf()\fP\&.
.SS "static double power (double base, int exp)\fC [static]\fP"

.PP
Definition at line \fB181\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
182 {
183     double res = 1\&.0;
184     for (int i = 0; i < exp; ++i)
185         res *= base;
186     return res;
187 }
.fi

.PP
References \fBbase\fP\&.
.PP
Referenced by \fBdoubleToString()\fP\&.
.SS "static void printCharStr (const char * str)\fC [static]\fP"

.PP
Definition at line \fB41\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
42 {
43     uint16_t *video_memory = (uint16_t *)0xb8000;
44     // FOR TEXT : Attribute for Gray\-White (0x7) text on a Black (0x0) background (last 2 bytes (LSBs) are not used for color)\&.
45     const uint16_t color_attribute = 0x0700;
46 
47     // \-\-\- MOUSE\-SAFE PRINTING: remove mouse \-\-\-
48     int mouse_offset = driver::MouseDriver::__mouse_y_ * MAGIC_WIDTH + driver::MouseDriver::__mouse_x_;
49     if(mouse_offset>=0) video_memory[mouse_offset] = driver::MouseDriver::old_char_under_mouse_pointer;
50 
51 
52     for (int i = 0; str[i] != '\\0'; i++)
53     {
54         if (str[i] == '\\n')
55         {
56             cursor_y_++;
57             cursor_x_ = 0;
58         }
59         else if (str[i] == '\\b')
60         {
61             if (cursor_x_ > 0)
62             {
63                 cursor_x_\-\-;
64                 int offset = cursor_y_ * MAGIC_WIDTH + cursor_x_;
65                 video_memory[offset] = color_attribute | ' ';
66             }
67         }
68         else if (str[i] == '\\r')
69         {
70             cursor_x_ = 0;
71         }
72         else if (str[i] == '\\t')
73         {
74             cursor_x_ = cursor_x_ + (TAB_WIDTH \- (cursor_x_ % TAB_WIDTH));
75         }
76         else
77         {
78             int offset = cursor_y_ * MAGIC_WIDTH + cursor_x_;
79             video_memory[offset] = color_attribute | str[i];
80             cursor_x_++;
81         }
82 
83         if (cursor_x_ >= MAGIC_WIDTH)
84         {
85             cursor_y_++;
86             cursor_x_ = 0;
87         }
88 
89         if (cursor_y_ >= MAGIC_HEIGHT)
90         {
91             for (int y = 0; y < (MAGIC_HEIGHT \- 1); y++)
92             {
93                 for (int x = 0; x < MAGIC_WIDTH; x++)
94                 {
95                     int current_offset = y * MAGIC_WIDTH + x;
96                     int next_line_offset = (y + 1) * MAGIC_WIDTH + x;
97                     video_memory[current_offset] = video_memory[next_line_offset];
98                 }
99             }
100 
101             int last_line_offset_start = (MAGIC_HEIGHT \- 1) * MAGIC_WIDTH;
102             for (int x = 0; x < MAGIC_WIDTH; x++)
103             {
104                 video_memory[last_line_offset_start + x] = color_attribute | ' ';
105             }
106 
107             cursor_y_ = MAGIC_HEIGHT \- 1;
108             cursor_x_ = 0;
109         }
110     }
111 
112     // \-\-\- MOUSE\-SAFE PRINTING: add mouse again\-\-\-
113     driver::MouseDriver::old_char_under_mouse_pointer = video_memory[mouse_offset];
114     if(mouse_offset>=0) video_memory[mouse_offset] = driver::MouseDriver::mouse_block_video_mem_value(driver::MouseDriver::old_char_under_mouse_pointer, MOUSE_POINTER_COLOR);
115 
116 }
.fi

.PP
References \fBdriver::MouseDriver::__mouse_x_\fP, \fBdriver::MouseDriver::__mouse_y_\fP, \fBcursor_x_\fP, \fBcursor_y_\fP, \fBMAGIC_HEIGHT\fP, \fBMAGIC_WIDTH\fP, \fBdriver::MouseDriver::mouse_block_video_mem_value()\fP, \fBMOUSE_POINTER_COLOR\fP, \fBdriver::MouseDriver::old_char_under_mouse_pointer\fP, and \fBTAB_WIDTH\fP\&.
.PP
Referenced by \fBbasic::printf()\fP, and \fBprintHex()\fP\&.
.SS "static void printHex (uintptr_t n, int digits)\fC [static]\fP"

.PP
Definition at line \fB227\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
227                                               {
228     char buffer[32];
229     ullToString(n, buffer, 16, 0, 1); // Use uppercase for pointers typically
230 
231     int len = 0;
232     while (buffer[len] != '\\0') {
233         len++;
234     }
235 
236     for (int i = 0; i < digits \- len; i++) {
237         printCharStr("0");
238     }
239     printCharStr(buffer);
240 }
.fi

.PP
References \fBlen\fP, \fBprintCharStr()\fP, and \fBullToString()\fP\&.
.PP
Referenced by \fBbasic::printf()\fP\&.
.SS "static void reverse (char * str, int length)\fC [static]\fP"

.PP
Definition at line \fB133\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
134 {
135     int start = 0;
136     int end = length \- 1;
137     while (start < end)
138     {
139         char temp = str[start];
140         str[start] = str[end];
141         str[end] = temp;
142         start++;
143         end\-\-;
144     }
145 }
.fi

.PP
Referenced by \fBullToString()\fP\&.
.SS "static void ullToString (unsigned long long n, char * buffer, int base, int is_signed, int uppercase)\fC [static]\fP"

.PP
Definition at line \fB147\fP of file \fBkiostream\&.cpp\fP\&..PP
.nf
148 {
149     int i = 0;
150     int isNegative = 0;
151 
152     if (n == 0)
153     {
154         buffer[i++] = '0';
155         buffer[i] = '\\0';
156         return;
157     }
158 
159     if (is_signed && (long long)n < 0)
160     {
161         isNegative = 1;
162         n = \-(long long)n;
163     }
164 
165     while (n != 0)
166     {
167         int rem = n % base;
168         buffer[i++] = (rem > 9) ? ((rem \- 10) + (uppercase ? 'A' : 'a')) : (rem + '0');
169         n = n / base;
170     }
171 
172     if (isNegative)
173     {
174         buffer[i++] = '\-';
175     }
176 
177     buffer[i] = '\\0';
178     reverse(buffer, i);
179 }
.fi

.PP
References \fBbase\fP, and \fBreverse()\fP\&.
.PP
Referenced by \fBdoubleToString()\fP, \fBbasic::printf()\fP, and \fBprintHex()\fP\&.
.SH "Variable Documentation"
.PP 
.SS "int cursor_x_ = 0\fC [static]\fP"

.PP
Definition at line \fB4\fP of file \fBkiostream\&.cpp\fP\&.
.PP
Referenced by \fBbasic::__clearScreen()\fP, \fBprintCharStr()\fP, \fBbasic::printf()\fP, and \fBbasic::update_cursor()\fP\&.
.SS "int cursor_y_ = 0\fC [static]\fP"

.PP
Definition at line \fB5\fP of file \fBkiostream\&.cpp\fP\&.
.PP
Referenced by \fBbasic::__clearScreen()\fP, \fBprintCharStr()\fP, \fBbasic::printf()\fP, and \fBbasic::update_cursor()\fP\&.
.SS "\fBhardware_communication::Port8Bit\fP vgaDataPort(0x3D5) (0x3D5)\fC [static]\fP"

.PP
Referenced by \fBbasic::disable_cursor()\fP, \fBbasic::enable_cursor()\fP, and \fBbasic::update_cursor()\fP\&.
.SS "\fBhardware_communication::Port8Bit\fP vgaIndexPort(0x3D4) (0x3D4)\fC [static]\fP"

.PP
Referenced by \fBbasic::disable_cursor()\fP, \fBbasic::enable_cursor()\fP, and \fBbasic::update_cursor()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for OSOS - Documentation from the source code\&.
