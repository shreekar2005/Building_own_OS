.TH "driver::KeyboardDriver" 3 "Thu Oct 23 2025 23:59:22" "OSOS - 32-bit Operating System" \" -*- nroff -*-
.ad l
.nh
.SH NAME
driver::KeyboardDriver
.SH SYNOPSIS
.br
.PP
.PP
\fC#include 'kkeyboard\&.hpp'\fP
.PP
Inherits \fBhardware_communication::InterruptHandler\fP, and \fBdriver::Driver\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKeyboardDriver\fP (\fBhardware_communication::InterruptManager\fP *\fBinterrupt_manager\fP, \fBKeyboardEventHandler\fP *\fBkeyboardEventHandler\fP)"
.br
.ti -1c
.RI "\fB~KeyboardDriver\fP ()"
.br
.ti -1c
.RI "void \fBactivate\fP () override"
.br
.ti -1c
.RI "void \fBdeactivate\fP () override"
.br
.ti -1c
.RI "uint32_t \fBhandleInterrupt\fP (uint32_t esp) override"
.br
.ti -1c
.RI "virtual uintptr_t \fBhandleInterrupt\fP (uintptr_t esp)=0"
.br
.ti -1c
.RI "int \fBreset\fP () override"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBInterruptManager\fP * \fBinterrupt_manager\fP"
.br
.ti -1c
.RI "uint8_t \fBinterruptNumber\fP"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "bool \fBcaps_on\fP"
.br
.ti -1c
.RI "\fBhardware_communication::Port8Bit\fP \fBcommandPort\fP"
.br
.ti -1c
.RI "\fBhardware_communication::Port8Bit\fP \fBdataPort\fP"
.br
.ti -1c
.RI "\fBKeyboardEventHandler\fP * \fBkeyboardEventHandler\fP"
.br
.ti -1c
.RI "uint8_t \fBled_byte_to_send\fP"
.br
.ti -1c
.RI "bool \fBshift_pressed\fP"
.br
.ti -1c
.RI "bool \fBwaiting_for_led_ack\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB17\fP of file \fBkkeyboard\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "driver::KeyboardDriver::KeyboardDriver (\fBhardware_communication::InterruptManager\fP * interrupt_manager, \fBdriver::KeyboardEventHandler\fP * keyboardEventHandler)"

.PP
Definition at line \fB13\fP of file \fBkkeyboard\&.cpp\fP\&..PP
.nf
14 : hardware_communication::InterruptHandler(0x21, interrupt_manager), 
15   dataPort(0x60), 
16   commandPort(0x64),
17   shift_pressed(false),
18   caps_on(false),
19   waiting_for_led_ack(false){
20     this\->keyboardEventHandler=keyboardEventHandler;
21   }
.fi

.PP
References \fBkeyboardEventHandler\fP\&.
.SS "driver::KeyboardDriver::~KeyboardDriver ()"

.PP
Definition at line \fB23\fP of file \fBkkeyboard\&.cpp\fP\&..PP
.nf
23 {}
.fi

.SH "Member Function Documentation"
.PP 
.SS "void driver::KeyboardDriver::activate ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Implements \fBdriver::Driver\fP\&.
.PP
Definition at line \fB167\fP of file \fBkkeyboard\&.cpp\fP\&..PP
.nf
167                                    {
168     while(commandPort\&.read() & 1) dataPort\&.read();
169     commandPort\&.write(0xAE); // activate communication for keyboard
170     commandPort\&.write(0x20); // get current state
171     uint8_t status = (dataPort\&.read() | 1) & ~0x10; // set LSB and clear 5th bit
172     commandPort\&.write(0x60); // set state
173     dataPort\&.write(status);
174     dataPort\&.write(0xF4);
175     basic::printf("Keyboard Driver activated!\\n");
176 }
.fi

.PP
References \fBbasic::printf()\fP\&.
.SS "void driver::KeyboardDriver::deactivate ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Implements \fBdriver::Driver\fP\&.
.PP
Definition at line \fB179\fP of file \fBkkeyboard\&.cpp\fP\&..PP
.nf
179 {}
.fi

.SS "uint32_t driver::KeyboardDriver::handleInterrupt (uint32_t esp)\fC [override]\fP"

.PP
Definition at line \fB25\fP of file \fBkkeyboard\&.cpp\fP\&..PP
.nf
25                                                           {
26     // Unshifted keys
27     static const char scancode_no_shift[] = {
28         0,   0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '\-', '=', '\\b',
29         '\\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\n',
30         0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\\'', '`', 0,
31         '\\\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '\&.', '/', 0, '*', 0,
32         ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
33         0, 0, 0, 0, 0,
34     };
35 
36     // Shifted keys
37     static const char scancode_shifted[] = {
38         0,   0, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '\\b',
39         '\\t', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', '\\n',
40         0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"', '~', 0,
41         '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?', 0, '*', 0,
42         ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
43         0, 0, 0, 0, 0,
44     };
45 
46     uint8_t scancode = dataPort\&.read();
47     if(keyboardEventHandler==0) return esp; //if dont have any handler just return
48 
49 
50     if (this\->waiting_for_led_ack) {
51         if (scancode == 0xFA) { // Got ACK
52             dataPort\&.write(this\->led_byte_to_send);
53             this\->waiting_for_led_ack = false;
54         }
55         // If we get something else, the keyboard is out of sync\&.
56         // We'll just drop out of the ACK\-waiting state and process
57         // the scancode normally (by falling through)\&.
58         else {
59              this\->waiting_for_led_ack = false;
60         }
61 
62         // If we got the ACK, we're done for this interrupt\&.
63         if (scancode == 0xFA) {
64             return esp;
65         }
66     }
67 
68 
69     // Check for key release
70     if (scancode & 0x80) {
71         scancode \-= 0x80; 
72         switch(scancode) {
73             case 0x2A: // Left Shift Release
74             case 0x36: // Right Shift Release
75                 this\->shift_pressed = false;
76                 break;
77             
78             // Handle release of all other keys
79             default: {
80                 char ascii = 0;
81                 if (scancode < sizeof(scancode_no_shift)) {
82                     
83                     char base_char = scancode_no_shift[scancode];
84 
85                     // Determine the character that was released based on the keyboard state
86                     if (base_char >= 'a' && base_char <= 'z') {
87                         if (this\->shift_pressed ^ this\->caps_on) {
88                             ascii = scancode_shifted[scancode];
89                         } else {
90                             ascii = base_char;
91                         }
92                     } else {
93                         if (this\->shift_pressed) {
94                             ascii = scancode_shifted[scancode];
95                         } else {
96                             ascii = base_char;
97                         }
98                     }
99                     if (ascii != 0) {
100                         keyboardEventHandler\->onKeyUp(ascii);
101                     }
102                 }
103                 break;
104             }
105         }
106     } 
107 
108     // Check for key press
109     else {
110         switch(scancode) {
111             case 0x2A: // Left Shift Press
112             case 0x36: // Right Shift Press
113                 this\->shift_pressed = true;
114                 break;
115 
116             case 0x3A: // Caps Lock Press
117                 this\->caps_on = !this\->caps_on; // Toggle the state
118                 
119                 // Prepare to send LED update
120                 this\->led_byte_to_send = 0;
121                 if (this\->caps_on) this\->led_byte_to_send |= 0x04; // Bit 2 for Caps Lock LED
122                 
123                 dataPort\&.write(0xED); // Send "Set LEDs" command
124                 this\->waiting_for_led_ack = true; // Set state to wait for ACK
125                 break;
126 
127             default: {
128                 // It's a printable key
129                 char ascii = 0;
130                 if (scancode < sizeof(scancode_no_shift)) {
131                     
132                     char base_char = scancode_no_shift[scancode];
133 
134                     // Check if it's an alphabet character
135                     if (base_char >= 'a' && base_char <= 'z') {
136                         // It's a letter\&. Apply Shift XOR Caps Lock
137                         // (shift ^ caps) = true means capitalize
138                         if (this\->shift_pressed ^ this\->caps_on) {
139                             ascii = scancode_shifted[scancode]; // Uppercase
140                         } else {
141                             ascii = base_char; // Lowercase
142                         }
143                     } else {
144                         // It's not a letter (number, symbol, etc\&.)
145                         // Only Shift applies
146                         if (this\->shift_pressed) {
147                             ascii = scancode_shifted[scancode];
148                         } else {
149                             ascii = base_char;
150                         }
151                     }
152                     keyboardEventHandler\->onKeyDown(ascii);
153                 }
154                 break;
155             }
156         }
157     }
158 
159     return esp;
160 }
.fi

.PP
References \fBdriver::KeyboardEventHandler::onKeyUp()\fP\&.
.SS "virtual uintptr_t hardware_communication::InterruptHandler::handleInterrupt (uintptr_t esp)\fC [pure virtual]\fP, \fC [inherited]\fP"

.PP
Referenced by \fBhardware_communication::InterruptManager::handleInterrupt()\fP\&.
.SS "int driver::KeyboardDriver::reset ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Implements \fBdriver::Driver\fP\&.
.PP
Definition at line \fB178\fP of file \fBkkeyboard\&.cpp\fP\&..PP
.nf
178 {return 0;}
.fi

.SH "Member Data Documentation"
.PP 
.SS "bool driver::KeyboardDriver::caps_on\fC [private]\fP"

.PP
Definition at line \fB23\fP of file \fBkkeyboard\&.hpp\fP\&.
.SS "\fBhardware_communication::Port8Bit\fP driver::KeyboardDriver::commandPort\fC [private]\fP"

.PP
Definition at line \fB19\fP of file \fBkkeyboard\&.hpp\fP\&.
.SS "\fBhardware_communication::Port8Bit\fP driver::KeyboardDriver::dataPort\fC [private]\fP"

.PP
Definition at line \fB18\fP of file \fBkkeyboard\&.hpp\fP\&.
.SS "\fBInterruptManager\fP* hardware_communication::InterruptHandler::interrupt_manager\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line \fB26\fP of file \fBkinterrupt\&.hpp\fP\&.
.PP
Referenced by \fBhardware_communication::InterruptHandler::InterruptHandler()\fP\&.
.SS "uint8_t hardware_communication::InterruptHandler::interruptNumber\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line \fB25\fP of file \fBkinterrupt\&.hpp\fP\&.
.PP
Referenced by \fBhardware_communication::InterruptHandler::InterruptHandler()\fP\&.
.SS "\fBKeyboardEventHandler\fP* driver::KeyboardDriver::keyboardEventHandler\fC [private]\fP"

.PP
Definition at line \fB27\fP of file \fBkkeyboard\&.hpp\fP\&.
.PP
Referenced by \fBKeyboardDriver()\fP\&.
.SS "uint8_t driver::KeyboardDriver::led_byte_to_send\fC [private]\fP"

.PP
Definition at line \fB25\fP of file \fBkkeyboard\&.hpp\fP\&.
.SS "bool driver::KeyboardDriver::shift_pressed\fC [private]\fP"

.PP
Definition at line \fB21\fP of file \fBkkeyboard\&.hpp\fP\&.
.SS "bool driver::KeyboardDriver::waiting_for_led_ack\fC [private]\fP"

.PP
Definition at line \fB24\fP of file \fBkkeyboard\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for OSOS - 32-bit Operating System from the source code\&.
